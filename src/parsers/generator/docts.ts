/**
 * @fileoverview Self-documenting generator parsers with introspection capabilities.
 * 
 * This module provides utilities for creating generator parsers that can document
 * themselves, generating human-readable descriptions of their parsing logic.
 * This is invaluable for debugging, testing, and creating documentation for
 * complex parsing grammars.
 * 
 * The self-documentation feature works by performing a "dry run" of the generator
 * function to collect information about each parsing step, then formatting this
 * information into readable documentation. This approach provides:
 * 
 * - Automatic documentation generation from parser code
 * - Step-by-step parsing descriptions for debugging
 * - Grammar documentation for language specifications
 * - Integration with testing and development tools
 * 
 * @example
 * ```typescript
 * const configParser = documentedGenParser(
 *   "Configuration file parser",
 *   function* () {
 *     const key = yield identifier;
 *     yield str('=');
 *     const value = yield stringLiteral;
 *     return { [key]: value };
 *   }
 * );
 * 
 * console.log(configParser.docs());
 * // Outputs: step-by-step documentation of the parsing process
 * ```
 */

import { Parser } from "../../parser";
import { genParser } from "./generator";

/**
 * Creates a documented generator parser with introspection capabilities.
 * 
 * This function wraps a generator parser with documentation functionality,
 * allowing it to generate human-readable descriptions of its parsing logic.
 * The documentation is generated by performing a dry run of the generator
 * to collect metadata about each parsing step.
 * 
 * The resulting parser behaves identically to a regular generator parser
 * but includes a `docs()` method that returns formatted documentation.
 * This is particularly useful for:
 * 
 * - Creating grammar documentation
 * - Debugging complex parsers
 * - Generating test descriptions
 * - Providing user-friendly error messages
 * 
 * @template T - The type of value produced by the parser
 * @param description - High-level description of what the parser does
 * @param genFn - The generator function that defines the parsing logic
 * @returns A parser with additional documentation methods
 * 
 * @example
 * ```typescript
 * // Create a documented JSON object parser
 * const jsonObjectParser = documentedGenParser(
 *   "JSON object parser",
 *   function* () {
 *     yield str('{');
 *     
 *     const pairs = yield* genPatterns.list(
 *       function* () {
 *         const key = yield stringLiteral;
 *         yield str(':');
 *         const value = yield jsonValue;
 *         return [key, value];
 *       },
 *       str(',')
 *     );
 *     
 *     yield str('}');
 *     return Object.fromEntries(pairs);
 *   }
 * );
 * 
 * // Generate documentation
 * console.log(jsonObjectParser.docs());
 * // Outputs:
 * // JSON object parser
 * // 
 * // Steps:
 * // 1. Parse step
 * // 2. Parse step
 * // 3. Parse step
 * ```
 * 
 * @example
 * ```typescript
 * // Document a complex expression parser
 * const exprParser = documentedGenParser(
 *   "Mathematical expression parser with precedence",
 *   function* () {
 *     const left = yield term;
 *     const rest = yield* gen.while(
 *       choice([str('+'), str('-')]),
 *       sequence([
 *         choice([str('+'), str('-')]),
 *         term
 *       ])
 *     );
 *     return buildExpressionTree(left, rest);
 *   }
 * );
 * ```
 */
export function documentedGenParser<T>(
  description: string,
  genFn: () => Generator<Parser<any>, T, any>
): Parser<T> & { docs: () => string } {
  const parser = genParser(genFn);

  return Object.assign(parser, {
    /**
     * Generates human-readable documentation for this parser.
     * 
     * This method performs a dry run of the generator function to collect
     * information about each parsing step, then formats it into readable
     * documentation. The documentation includes the high-level description
     * and a step-by-step breakdown of the parsing process.
     * 
     * Note: The dry run may not capture all dynamic behavior of the parser,
     * particularly conditional logic that depends on parsed values. However,
     * it provides a good overview of the parser's structure and intent.
     * 
     * @returns Formatted documentation string describing the parser's behavior
     * 
     * @example
     * ```typescript
     * const parser = documentedGenParser("Example", function* () {
     *   yield str('hello');
     *   yield whitespace;
     *   yield str('world');
     *   return 'greeting';
     * });
     * 
     * console.log(parser.docs());
     * // Output:
     * // Example
     * // 
     * // Steps:
     * // 1. Parse step
     * // 2. Parse step  
     * // 3. Parse step
     * ```
     */
    docs: () => {
      const steps: string[] = [];

      try {
        // Perform a dry run to collect steps
        const iterator = genFn();
        let stepNum = 1;

        while (true) {
          const { value, done } = iterator.next();
          if (done) break;

          const parser = value as Parser<any>;
          // Try to get a meaningful description from the parser
          const parserDescription = getParserDescription(parser);
          steps.push(`${stepNum}. ${parserDescription}`);
          stepNum++;
        }
      } catch (error) {
        steps.push(`Documentation generation failed: ${error}`);
      }

      return `${description}\n\nSteps:\n${steps.join('\n')}`;
    }
  });
}

/**
 * Attempts to generate a meaningful description for a parser.
 * 
 * This helper function tries various methods to extract or generate
 * a human-readable description of what a parser does. It checks for
 * custom toString methods, constructor names, and falls back to
 * generic descriptions.
 * 
 * @param parser - The parser to describe
 * @returns A human-readable description of the parser
 * 
 * @internal
 */
function getParserDescription(parser: Parser<any>): string {
  // Check if the parser has a custom toString method
  if (parser.toString && parser.toString !== Object.prototype.toString) {
    const desc = parser.toString();
    if (desc !== '[object Object]') {
      return desc;
    }
  }

  // Check constructor name for built-in parsers
  const constructorName = parser.constructor.name;
  if (constructorName && constructorName !== 'Object' && constructorName !== 'Parser') {
    return `${constructorName} parser`;
  }

  // Check for common parser types by examining the parser function
  // This is a simplified heuristic - in a real implementation you might
  // want more sophisticated parser type detection
  const parserString = parser.toString();
  
  if (parserString.includes('str(')) {
    return 'String literal parser';
  }
  if (parserString.includes('regex(')) {
    return 'Regular expression parser';
  }
  if (parserString.includes('choice(')) {
    return 'Choice parser';
  }
  if (parserString.includes('sequence(')) {
    return 'Sequence parser';
  }
  if (parserString.includes('optional(')) {
    return 'Optional parser';
  }
  if (parserString.includes('many(')) {
    return 'Repetition parser';
  }

  // Default fallback
  return 'Parse step';
}

/**
 * Creates enhanced documentation with additional metadata.
 * 
 * This function provides a more detailed documentation format that includes
 * performance notes, usage examples, and parser metadata. It's useful for
 * creating comprehensive grammar documentation.
 * 
 * @template T - The type of value produced by the parser
 * @param metadata - Additional information about the parser
 * @param genFn - The generator function that defines the parsing logic
 * @returns A parser with enhanced documentation capabilities
 * 
 * @example
 * ```typescript
 * const parser = documentedGenParserWithMetadata(
 *   {
 *     name: "JSON Array Parser",
 *     description: "Parses JSON arrays with proper nesting support",
 *     examples: ["[1,2,3]", "[\"a\",\"b\"]", "[]"],
 *     performance: "O(n) where n is array length",
 *     notes: "Supports nested arrays and mixed types"
 *   },
 *   function* () {
 *     // ... parser implementation
 *   }
 * );
 * ```
 */
export function documentedGenParserWithMetadata<T>(
  metadata: {
    name: string;
    description: string;
    examples?: string[];
    performance?: string;
    notes?: string;
  },
  genFn: () => Generator<Parser<any>, T, any>
): Parser<T> & { docs: () => string; metadata: typeof metadata } {
  const baseParser = documentedGenParser(metadata.description, genFn);

  return Object.assign(baseParser, {
    metadata,
    docs: () => {
      const baseDocs = baseParser.docs();
      const additionalInfo: string[] = [];

      if (metadata.examples && metadata.examples.length > 0) {
        additionalInfo.push(`\nExamples:\n${metadata.examples.map(ex => `  - ${ex}`).join('\n')}`);
      }

      if (metadata.performance) {
        additionalInfo.push(`\nPerformance: ${metadata.performance}`);
      }

      if (metadata.notes) {
        additionalInfo.push(`\nNotes: ${metadata.notes}`);
      }

      return `${metadata.name}\n\n${baseDocs}${additionalInfo.join('')}`;
    }
  });
}
